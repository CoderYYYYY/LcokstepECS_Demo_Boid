
//------------------------------------------------------------------------------    
// <auto-generated>                                                                 
//     This code was generated by Tools.MacroExpansion, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null. 
//     https://github.com/JiepengTan/LockstepEngine                                          
//     Changes to this file may cause incorrect behavior and will be lost if        
//     the code is regenerated.                                                     
// </auto-generated>                                                                
//------------------------------------------------------------------------------  

//Power by ME //src: https://github.com/JiepengTan/ME  

//#define DONT_USE_GENERATE_CODE                                                                 
                                                                                                 
using System.Linq;                                                                               
using Lockstep.Serialization;                                                                    
using System.Runtime.InteropServices;                                                            
using System.Runtime.CompilerServices;                                                            
using System;                                                                                    
using Lockstep.InternalUnsafeECS;                                                               
using System.Collections;                                                                        
using Lockstep.Math;                                                                             
using System.Collections.Generic;                                                                
using Lockstep.Logging;                                                                          
using Lockstep.Util;                                                                          
using Lockstep.Math;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Transforms;

namespace Lockstep.UnsafeECS.Game {
    public struct UnityBoidTag : IComponentData { }
    public struct UnityBoidObstacleTag : IComponentData { }        

    [UpdateInGroup(typeof(SimulationSystemGroup))]
    [UpdateBefore(typeof(TransformSystemGroup))]
    public unsafe class UpdateViewStateSystem : JobComponentSystem {

        private void CopyState<T>(ref NativeEntityArray<T> ary,ref NativeArray<T> entityAry )where T : unmanaged, IEntity{
            if (ary.Length != 0) {
                if (entityAry.Length == ary._EntityAry.Length) {
                    NativeArray<T>.Copy(ary._EntityAry, entityAry);
                }
                else {
                    if (entityAry.Length != 0) {
                        entityAry.Dispose();
                    }
                    entityAry = new NativeArray<T>(ary._EntityAry, Allocator.Persistent);
                }
            }
            else {
                if (entityAry.Length != 0) {
                    entityAry.Dispose();
                }
            }
        }

        public static bool isInited = false;
        private EntityQuery _BoidQuery;
        public NativeArray<Boid> _allBoids;

        [BurstCompile]
        unsafe struct _UpdateBoid : IJobForEachWithEntity<Unity.Transforms.LocalToWorld, EntityRef> {
            [ReadOnly] public NativeArray<Boid> allBoids;

            public void Execute(Unity.Entities.Entity entity, int index,
                ref Unity.Transforms.LocalToWorld localToWorld, ref EntityRef entityRef){
                var ptr = allBoids.GetPointer(entityRef._index);
                if (ptr->EntityRef == entityRef) {
                    localToWorld = new Unity.Transforms.LocalToWorld {
                        Value = float4x4.TRS(
                            ptr->Transform.Position.ToVector3(),
                            quaternion.LookRotationSafe(ptr->Transform.Forward.ToVector3(),
                                Unity.Mathematics.math.up()),
                            new Unity.Mathematics.float3(ptr->Transform.Scale)
                        )
                    };
                }
            }
        }

        private void _ScheduleBoid(ref JobHandle inputDeps)  
        {
            var ary = Context.Instance._entities._BoidAry;
            CopyState(ref ary,ref _allBoids);
            if (ary.Length != 0) {
                var steerJob = new _UpdateBoid {
                    allBoids = _allBoids,
                };
                inputDeps = steerJob.Schedule(_BoidQuery, inputDeps);
            }
        }  
        private EntityQuery _BoidObstacleQuery;
        public NativeArray<BoidObstacle> _allBoidObstacles;

        [BurstCompile]
        unsafe struct _UpdateBoidObstacle : IJobForEachWithEntity<Unity.Transforms.LocalToWorld, EntityRef> {
            [ReadOnly] public NativeArray<BoidObstacle> allBoidObstacles;

            public void Execute(Unity.Entities.Entity entity, int index,
                ref Unity.Transforms.LocalToWorld localToWorld, ref EntityRef entityRef){
                var ptr = allBoidObstacles.GetPointer(entityRef._index);
                if (ptr->EntityRef == entityRef) {
                    localToWorld = new Unity.Transforms.LocalToWorld {
                        Value = float4x4.TRS(
                            ptr->Transform.Position.ToVector3(),
                            quaternion.LookRotationSafe(ptr->Transform.Forward.ToVector3(),
                                Unity.Mathematics.math.up()),
                            new Unity.Mathematics.float3(ptr->Transform.Scale)
                        )
                    };
                }
            }
        }

        private void _ScheduleBoidObstacle(ref JobHandle inputDeps)  
        {
            var ary = Context.Instance._entities._BoidObstacleAry;
            CopyState(ref ary,ref _allBoidObstacles);
            if (ary.Length != 0) {
                var steerJob = new _UpdateBoidObstacle {
                    allBoidObstacles = _allBoidObstacles,
                };
                inputDeps = steerJob.Schedule(_BoidObstacleQuery, inputDeps);
            }
        }          

        protected override JobHandle OnUpdate(JobHandle inputDeps){
            if (Context.Instance.HasInit) {
                _ScheduleBoid(ref inputDeps);
                _ScheduleBoidObstacle(ref inputDeps);        
            }

            return inputDeps;
        }

        protected override void OnCreate(){
            _BoidQuery = GetEntityQuery(new EntityQueryDesc {
                All = new[] {
                    ComponentType.ReadOnly<UnityBoidTag>(),
                    ComponentType.ReadWrite<EntityRef>(),
                    ComponentType.ReadWrite<Unity.Transforms.LocalToWorld>()
                },
            });
            _BoidObstacleQuery = GetEntityQuery(new EntityQueryDesc {
                All = new[] {
                    ComponentType.ReadOnly<UnityBoidObstacleTag>(),
                    ComponentType.ReadWrite<EntityRef>(),
                    ComponentType.ReadWrite<Unity.Transforms.LocalToWorld>()
                },
            });        
        }
    }
}                                                                                
                                                                                         